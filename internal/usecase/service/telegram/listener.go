package telegram

import (
	"bytes"
	"compress/gzip"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"postic-backend/internal/entity"
	"postic-backend/internal/repo"
	"postic-backend/internal/usecase"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
	"github.com/google/uuid"
	"github.com/labstack/gommon/log"
)

type EventListener struct {
	bot                       *bot.Bot
	ctx                       context.Context
	cancel                    context.CancelFunc
	telegramEventListenerRepo repo.TelegramListener
	teamRepo                  repo.Team
	postRepo                  repo.Post
	uploadUseCase             usecase.Upload
	commentRepo               repo.Comment
	analyticsRepo             repo.Analytics
	eventRepo                 repo.CommentEventRepository

	// –ë—É—Ñ–µ—Ä –¥–ª—è –º–µ–¥–∏–∞–≥—Ä—É–ø–ø: media_group_id -> []*models.Update
	mediaGroupBuffer map[string][]*models.Update
	// –¢–∞–π–º–µ—Ä—ã –¥–ª—è –º–µ–¥–∏–∞–≥—Ä—É–ø–ø: media_group_id -> *time.Timer
	mediaGroupTimers map[string]*time.Timer
	// –ú—å—é—Ç–µ–∫—Å –¥–ª—è –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
	mediaGroupMutex sync.Mutex
}

func NewTelegramEventListener(
	token string,
	debug bool,
	telegramEventListenerRepo repo.TelegramListener,
	teamRepo repo.Team,
	postRepo repo.Post,
	uploadUseCase usecase.Upload,
	commentRepo repo.Comment,
	analyticsRepo repo.Analytics,
	eventRepo repo.CommentEventRepository,
) (usecase.Listener, error) {
	lastUpdateID, err := telegramEventListenerRepo.GetLastUpdate()
	for err != nil {
		// –ü—ã—Ç–∞–µ–º—Å—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π event
		log.Errorf("Post GetLastUpdate failed: %v", err)
		time.Sleep(1 * time.Second)
		lastUpdateID, err = telegramEventListenerRepo.GetLastUpdate()
	}
	opts := []bot.Option{
		bot.WithInitialOffset(int64(lastUpdateID)),
		bot.WithAllowedUpdates([]string{
			"message",                // –û–±—ã—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
			"edited_message",         // –û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
			"message_reaction",       // –†–µ–∞–∫—Ü–∏–∏ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
			"message_reaction_count", // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∞–∫—Ü–∏–π
		}),
	}
	if debug {
		opts = append(opts, bot.WithDebug())
	}

	telegramBot, err := bot.New(token, opts...)
	if err != nil {
		return nil, err
	}

	// –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –æ—Ç–º–µ–Ω—ã
	ctx, cancel := context.WithCancel(context.Background())

	// –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ
	botInfo, err := telegramBot.GetMe(ctx)
	if err != nil {
		cancel()
		return nil, err
	}

	log.Infof("Authorized on account %s", botInfo.Username)

	return &EventListener{
		bot:                       telegramBot,
		ctx:                       ctx,
		cancel:                    cancel,
		telegramEventListenerRepo: telegramEventListenerRepo,
		teamRepo:                  teamRepo,
		postRepo:                  postRepo,
		uploadUseCase:             uploadUseCase,
		commentRepo:               commentRepo,
		analyticsRepo:             analyticsRepo,
		eventRepo:                 eventRepo,
		mediaGroupBuffer:          make(map[string][]*models.Update),
		mediaGroupTimers:          make(map[string]*time.Timer),
	}, nil
}

func (t *EventListener) StartListener() {
	t.setupHandlers()
	t.bot.Start(context.TODO())
}

func (t *EventListener) StopListener() {
	// –û—Ç–º–µ–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç, —á—Ç–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–æ–ª—É—á–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
	t.cancel()
}

// saveLastUpdateID —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
func (t *EventListener) saveLastUpdateID(updateID int) {
	err := t.telegramEventListenerRepo.SetLastUpdate(updateID)
	if err != nil {
		log.Errorf("Failed to save last update ID %d: %v", updateID, err)
	}
}

func (t *EventListener) UpdateStats(update *models.Update) {
	tgChannel, err := t.teamRepo.GetTGChannelByChannelID(int(update.MessageReactionCount.Chat.ID))
	if errors.Is(err, repo.ErrTGChannelNotFound) {
		log.Infof("Channel not found for discussion ID: %d", update.MessageReactionCount.Chat.ID)
		return
	}
	post, err := t.postRepo.GetPostPlatformByPost(
		update.MessageReactionCount.MessageID,
		tgChannel.ID,
		"tg",
	)
	switch {
	case errors.Is(err, repo.ErrPostPlatformNotFound):
		// –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–∞–∫—É—é –æ—à–∏–±–∫—É
		log.Infof("Post not found for message ID: %d", update.MessageReactionCount.MessageID)
		return
	case err != nil:
		log.Errorf("Failed to get post: %v", err)
		return
	}

	// –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∞–∫—Ü–∏–π
	totalReactions := 0
	if update.MessageReactionCount.Reactions != nil {
		for _, reaction := range update.MessageReactionCount.Reactions {
			totalReactions += reaction.TotalCount
		}
	}
	// –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∞–∫—Ü–∏–π –ø–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
	stats := &entity.PostPlatformStats{
		TeamID:      tgChannel.TeamID,
		PostUnionID: post.PostUnionId,
		Platform:    "tg",
		RecordedAt:  time.Now(),
		Reactions:   totalReactions,
	}

	log.Infof("Reactions: %v", stats.Reactions)
	err = t.analyticsRepo.SavePostPlatformStats(stats)
	if err != nil {
		log.Errorf("failed to update post platform stats: %v", err)
	}
}

func getExtensionForType(fileType string) string {
	switch fileType {
	case "photo":
		return "jpg"
	case "video":
		return "mp4"
	case "audio":
		return "mp3"
	case "voice":
		return "ogg"
	case "document":
		return "bin"
	case "sticker":
		return "webp"
	default:
		return "bin"
	}
}

func (t *EventListener) saveFile(fileID, fileType string) (int, error) {
	file, err := t.bot.GetFile(t.ctx, &bot.GetFileParams{
		FileID: fileID,
	})
	if err != nil {
		log.Errorf("Failed to get file: %v", err)
		return 0, err
	}

	// –ü–æ–ª—É—á–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
	url := t.bot.FileDownloadLink(file)
	resp, err := http.Get(url)
	if err != nil {
		log.Errorf("Failed to get file content: %v", err)
		return 0, err
	}
	defer func() { _ = resp.Body.Close() }()

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ TGS-—Å—Ç–∏–∫–µ—Ä
	isTGS := fileType == "sticker" && strings.HasSuffix(file.FilePath, ".tgs")

	var extension string
	var body io.Reader
	body = resp.Body

	if file.FilePath != "" && strings.Contains(file.FilePath, ".") {
		parts := strings.Split(file.FilePath, ".")
		extension = parts[len(parts)-1]
	} else {
		extension = getExtensionForType(fileType)
	}

	if isTGS {
		// –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å—Ç–∏–∫–µ—Ä–∞
		tgsData, err := io.ReadAll(body)
		if err != nil {
			log.Errorf("Failed to read sticker data: %v", err)
			return 0, err
		}
		gzipReader, err := gzip.NewReader(bytes.NewReader(tgsData))
		if err != nil {
			log.Errorf("Failed to create gzip reader: %v", err)
			return 0, err
		}
		defer func() { _ = gzipReader.Close() }()
		lottieJSON, err := io.ReadAll(gzipReader)
		if err != nil {
			log.Errorf("Failed to read lottie JSON data: %v", err)
			return 0, err
		}
		body = bytes.NewReader(lottieJSON)
		extension = "json"
	}

	bodyData, err := io.ReadAll(body)
	if err != nil {
		log.Errorf("Failed to read file data: %v", err)
		return 0, err
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ S3
	upload := &entity.Upload{
		RawBytes: bytes.NewReader(bodyData),
		FilePath: fmt.Sprintf("tg/%s.%s", uuid.New().String(), extension),
		FileType: fileType,
	}
	uploadFileId, err := t.uploadUseCase.UploadFile(upload)
	if err != nil {
		log.Errorf("Failed to upload file: %v", err)
		return 0, err
	}
	return uploadFileId, nil
}

func (t *EventListener) handleForwardedMessage(update *models.Update) error {
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –∫–∞–Ω–∞–ª–∞
	if update.Message.ForwardOrigin.Type != models.MessageOriginTypeChannel {
		_, err := t.bot.SendMessage(t.ctx, &bot.SendMessageParams{
			ChatID: update.Message.Chat.ID,
			Text: "‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–ª–∞–Ω–æ –Ω–µ –∏–∑ –∫–∞–Ω–∞–ª–∞.\n" +
				"üîç –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –±–æ—Ç–∞ —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /help",
		})
		return err
	}

	channel := update.Message.ForwardOrigin.MessageOriginChannel
	channelID := channel.Chat.ID
	admins, err := t.bot.GetChatAdministrators(t.ctx, &bot.GetChatAdministratorsParams{
		ChatID: channelID,
	})
	if err != nil {
		_, err = t.bot.SendMessage(t.ctx, &bot.SendMessageParams{
			ChatID: update.Message.Chat.ID,
			Text:   "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –∫–∞–Ω–∞–ª–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –±–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∫–∞–Ω–∞–ª–∞.",
		})
		return err
	}
	// –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ
	botInfo, err := t.bot.GetMe(t.ctx)
	if err != nil {
		return err
	}
	isAdmin := false
	for _, admin := range admins {
		if admin.Administrator.User.ID == botInfo.ID {
			isAdmin = true
			break
		}
	}
	// –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–∞—Ç–µ
	chat, err := t.bot.GetChat(t.ctx, &bot.GetChatParams{
		ChatID: channelID,
	})
	if err != nil {
		return err
	}
	var discussionID int64
	if chat.LinkedChatID != 0 {
		discussionID = chat.LinkedChatID
	}
	if chat.LinkedChatID != 0 {
		discussionID = chat.LinkedChatID
	}
	var isDiscussionAdmin bool
	if discussionID != 0 {
		chatMember, err := t.bot.GetChatMember(t.ctx, &bot.GetChatMemberParams{
			ChatID: discussionID,
			UserID: botInfo.ID,
		})
		if err != nil {
			isDiscussionAdmin = false
		} else {
			isDiscussionAdmin = chatMember.Type == models.ChatMemberTypeAdministrator ||
				chatMember.Type == models.ChatMemberTypeOwner
		}
	}
	// –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
	var response string
	if isAdmin {
		response = fmt.Sprintf("‚úÖ –ë–æ—Ç —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –∫–∞–Ω–∞–ª–µ \"%s\".\n", channel.Chat.Title)
	} else {
		response = fmt.Sprintf("‚ùå –ë–æ—Ç –ù–ï —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –∫–∞–Ω–∞–ª–µ \"%s\"\n", channel.Chat.Title)
	}

	if discussionID != 0 {
		if isDiscussionAdmin {
			response += fmt.Sprintf(
				"‚úÖ –ë–æ—Ç —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º –≤ –æ–±—Å—É–∂–¥–µ–Ω–∏—è—Ö. \nID –∫–∞–Ω–∞–ª–∞: %d\nID –æ–±—Å—É–∂–¥–µ–Ω–∏–π: %d",
				channelID,
				discussionID,
			)
		} else {
			response += fmt.Sprintf(
				"‚ùå –ë–æ—Ç –ù–ï —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º –≤ –æ–±—Å—É–∂–¥–µ–Ω–∏—è—Ö.\nID –∫–∞–Ω–∞–ª–∞: %d\nID –æ–±—Å—É–∂–¥–µ–Ω–∏–π: %d",
				channelID,
				discussionID,
			)
		}
	} else {
		response += fmt.Sprintf("\nID –∫–∞–Ω–∞–ª–∞: %d\n–û–±—Å—É–∂–¥–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", channelID)
	}

	_, err = t.bot.SendMessage(t.ctx, &bot.SendMessageParams{
		ChatID: update.Message.Chat.ID,
		Text:   response,
	})
	return err
}

func (t *EventListener) handleCommand(update *models.Update) error {
	command := strings.Split(update.Message.Text, " ")[0][1:] // –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–∞–Ω–¥—É –±–µ–∑ '/'
	args := strings.TrimPrefix(update.Message.Text, "/"+command+" ")

	// –°–æ–∑–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –æ—Ç–≤–µ—Ç–∞
	params := &bot.SendMessageParams{
		ChatID: update.Message.Chat.ID,
	}

	switch command {
	case "start":
		params.Text = "‚ùáÔ∏è –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç, —É–ø—Ä–∞–≤–ª—è—é—â–∏–π —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π Postic. " +
			"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /help, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥."
	case "help":
		params.Text = "‚ùáÔ∏è –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å ID –∫–∞–Ω–∞–ª–∞ –∏ ID –æ–±—Å—É–∂–¥–µ–Ω–∏–π –∫–∞–Ω–∞–ª–∞, –ø–µ—Ä–µ—à–ª–∏—Ç–µ –º–Ω–µ –∏–∑ –∫–∞–Ω–∞–ª–∞ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n" +
			"–°–Ω–∞—á–∞–ª–∞ —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –±–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∫–∞–Ω–∞–ª–∞ –∏ –æ–±—Å—É–∂–¥–µ–Ω–∏–π (–µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –æ–±—Å—É–∂–¥–µ–Ω–∏—è, " +
			"–ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ –∫ –∫–∞–Ω–∞–ª—É).\n\n–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥:\n" +
			"/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n" +
			"/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥\n" +
			"/add_channel - –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª. –ï—Å–ª–∏ –∫–∞–Ω–∞–ª —É–∂–µ –ø—Ä–∏–≤—è–∑–∞–Ω, —Ç–æ –≤—ã–∑–æ–≤ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –æ–±–Ω–æ–≤–∏—Ç –µ–≥–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"
	case "add_channel":
		cmdArgs := strings.Fields(args)
		if len(cmdArgs) > 3 || len(cmdArgs) < 2 {
			params.Text = "‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: " +
				"/add_channel <–∫–ª—é—á –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è> <ID –∫–∞–Ω–∞–ª–∞> <ID –æ–±—Å—É–∂–¥–µ–Ω–∏–π (–ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏)>.\n" +
				"–ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –ø–æ–ª—É—á–∏—Ç—å ID –∫–∞–Ω–∞–ª–∞ –∏ ID –æ–±—Å—É–∂–¥–µ–Ω–∏–π, –º–æ–∂–µ—Ç–µ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∫–æ–º–∞–Ω–¥–æ–π /help.\n" +
				"–ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:\n" +
				"`/add_channel token123456 -123456789` - –µ—Å–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –æ–±—Å—É–∂–¥–µ–Ω–∏–π\n" +
				"`/add_channel token123456 -123456789 -123456789` - –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –æ–±—Å—É–∂–¥–µ–Ω–∏—è"
			_, err := t.bot.SendMessage(t.ctx, params)
			return err
		}
		secretKey := cmdArgs[0]
		channelID, err := strconv.ParseInt(cmdArgs[1], 10, 64)
		if err != nil || channelID >= 0 {
			params.Text = "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç channel_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ü–µ–ª–æ–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ."
			_, err := t.bot.SendMessage(t.ctx, params)
			return err
		}

		var discussionIDParsed int64
		if len(cmdArgs) > 2 {
			discussionIDParsed, err = strconv.ParseInt(cmdArgs[2], 10, 64)
			if err != nil || discussionIDParsed >= 0 {
				params.Text = "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç discussion_id. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ü–µ–ª–æ–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ."
				_, err := t.bot.SendMessage(t.ctx, params)
				return err
			}
		}

		teamId, err := t.teamRepo.GetTeamIDBySecret(secretKey)
		if err != nil {
			params.Text = "–ù–µ–≤–µ—Ä–Ω—ã–π —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á."
			_, err := t.bot.SendMessage(t.ctx, params)
			return err
		}
		discussionIDint := int(discussionIDParsed)
		err = t.teamRepo.PutTGChannel(&entity.TGChannel{
			TeamID:       teamId,
			ChannelID:    int(channelID),
			DiscussionID: &discussionIDint,
		})
		if err != nil {
			params.Text = "–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –≤–æ–ø—Ä–æ—Å–∞."
			_, err := t.bot.SendMessage(t.ctx, params)
			return err
		}
		params.Text = "–ö–∞–Ω–∞–ª —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –∏ –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É."
	default:
		params.Text = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥."
	}

	_, err := t.bot.SendMessage(t.ctx, params)
	return err
}

func (t *EventListener) processAttachments(update *models.Update) ([]*entity.Upload, error) {
	attachments := make([]*entity.Upload, 0)
	if len(update.Message.Photo) > 0 {
		uploadFileId, err := t.saveFile(update.Message.Photo[len(update.Message.Photo)-1].FileID, "photo")
		if err != nil {
			log.Errorf("Failed to save photo: %v", err)
			return nil, err
		}
		upload, err := t.uploadUseCase.GetUpload(uploadFileId)
		if err != nil {
			log.Errorf("Failed to get uploaded photo file: %v", err)
			return nil, err
		}
		attachments = append(attachments, upload)
	}
	if update.Message.Video != nil {
		uploadFileId, err := t.saveFile(update.Message.Video.FileID, "video")
		if err != nil {
			log.Errorf("Failed to save video: %v", err)
			return nil, err
		}
		upload, err := t.uploadUseCase.GetUpload(uploadFileId)
		if err != nil {
			log.Errorf("Failed to get uploaded video file: %v", err)
			return nil, err
		}
		attachments = append(attachments, upload)
	}
	// –§–∞–π–ª –Ω–µ –±–æ–ª—å—à–µ 100 –º–±
	if update.Message.Document != nil && update.Message.Document.FileSize < 100*1024*1024 {
		uploadFileId, err := t.saveFile(update.Message.Document.FileID, "document")
		if err != nil {
			log.Errorf("Failed to save document: %v", err)
			return nil, err
		}
		upload, err := t.uploadUseCase.GetUpload(uploadFileId)
		if err != nil {
			log.Errorf("Failed to get uploaded document file: %v", err)
			return nil, err
		}
		attachments = append(attachments, upload)
	}
	if update.Message.Audio != nil {
		uploadFileId, err := t.saveFile(update.Message.Audio.FileID, "audio")
		if err != nil {
			log.Errorf("Failed to save audio: %v", err)
			return nil, err
		}
		upload, err := t.uploadUseCase.GetUpload(uploadFileId)
		if err != nil {
			log.Errorf("Failed to get uploaded audio file: %v", err)
			return nil, err
		}
		attachments = append(attachments, upload)
	}
	if update.Message.Voice != nil {
		uploadFileId, err := t.saveFile(update.Message.Voice.FileID, "voice")
		if err != nil {
			log.Errorf("Failed to save voice: %v", err)
			return nil, err
		}
		upload, err := t.uploadUseCase.GetUpload(uploadFileId)
		if err != nil {
			log.Errorf("Failed to get uploaded voice file: %v", err)
			return nil, err
		}
		attachments = append(attachments, upload)
	}
	if update.Message.Sticker != nil {
		uploadFileId, err := t.saveFile(update.Message.Sticker.FileID, "sticker")
		if err != nil {
			log.Errorf("Failed to save sticker: %v", err)
			return nil, err
		}
		upload, err := t.uploadUseCase.GetUpload(uploadFileId)
		if err != nil {
			log.Errorf("Failed to get uploaded sticker file: %v", err)
			return nil, err
		}
		attachments = append(attachments, upload)
	}
	return attachments, nil
}

func (t *EventListener) setupHandlers() {
	t.bot.RegisterHandlerMatchFunc(
		func(update *models.Update) bool {
			return update.MessageReactionCount != nil
		},
		func(ctx context.Context, bot *bot.Bot, update *models.Update) {
			t.handleReactionUpdate(ctx, update)
		},
	)

	t.bot.RegisterHandlerMatchFunc(
		func(update *models.Update) bool {
			return update.Message != nil
		},
		func(ctx context.Context, bot *bot.Bot, update *models.Update) {
			t.handleMessageUpdate(ctx, update, false)
		},
	)

	t.bot.RegisterHandlerMatchFunc(
		func(update *models.Update) bool {
			return update.EditedMessage != nil
		},
		func(ctx context.Context, bot *bot.Bot, update *models.Update) {
			t.handleMessageUpdate(ctx, update, true)
		},
	)
}

func (t *EventListener) handleReactionUpdate(ctx context.Context, update *models.Update) {
	log.Infof("Received reactions: %v", update.MessageReactionCount.Reactions)
	t.UpdateStats(update)
	// –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
	t.saveLastUpdateID(int(update.ID))
}

func (t *EventListener) handleMessageUpdate(ctx context.Context, update *models.Update, isEdit bool) {
	var message *models.Message
	if isEdit {
		message = update.EditedMessage
		update.Message = message // –£–Ω–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
	} else {
		message = update.Message
	}

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ
	if t.isPrivateForwardedMessage(message) {
		err := t.handleForwardedMessage(update)
		if err != nil {
			log.Errorf("Failed to handle forwarded message: %v", err)
		}
		// –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
		t.saveLastUpdateID(int(update.ID))
		return
	}

	if t.isPrivateCommand(message) {
		err := t.handleCommand(update)
		if err != nil {
			log.Errorf("Failed to handle command: %v", err)
		}
		// –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
		t.saveLastUpdateID(int(update.ID))
		return
	}

	if t.isGroupMessage(message) {
		if isEdit {
			err := t.handleCommentEdit(ctx, update)
			if err != nil {
				log.Errorf("Failed to handle comment edit: %v", err)
			}
		} else {
			err := t.handleNewComment(ctx, update)
			if err != nil {
				log.Errorf("Failed to handle new comment: %v", err)
			}
		}
		// –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
		t.saveLastUpdateID(int(update.ID))
		return
	}
}

func (t *EventListener) isPrivateForwardedMessage(message *models.Message) bool {
	return message.ForwardOrigin != nil && message.Chat.Type == models.ChatTypePrivate
}

func (t *EventListener) isPrivateCommand(message *models.Message) bool {
	return message.Text != "" && strings.HasPrefix(message.Text, "/") && message.Chat.Type == models.ChatTypePrivate
}

func (t *EventListener) isGroupMessage(message *models.Message) bool {
	return message.Chat.Type != models.ChatTypePrivate
}

func (t *EventListener) handleNewComment(ctx context.Context, update *models.Update) error {
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
	if update.Message.From.Username == "" {
		return nil
	}

	tgChannel, post, replyToComment, err := t.getCommentContext(update)
	if err != nil {
		return err
	}
	if tgChannel == nil {
		return nil // –ö–∞–Ω–∞–ª –Ω–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è
	}

	// --- –ú–µ–¥–∏–∞–≥—Ä—É–ø–ø–∞: –µ—Å–ª–∏ –µ—Å—Ç—å media_group_id, –±—É—Ñ–µ—Ä–∏–∑—É–µ–º ---
	if update.Message.MediaGroupID != "" {
		groupID := update.Message.MediaGroupID
		t.mediaGroupMutex.Lock()
		t.mediaGroupBuffer[groupID] = append(t.mediaGroupBuffer[groupID], update)
		if t.mediaGroupTimers[groupID] == nil {
			t.mediaGroupTimers[groupID] = time.AfterFunc(700*time.Millisecond, func() {
				t.mediaGroupMutex.Lock()
				updates := t.mediaGroupBuffer[groupID]
				delete(t.mediaGroupBuffer, groupID)
				delete(t.mediaGroupTimers, groupID)
				t.mediaGroupMutex.Unlock()
				if len(updates) == 0 {
					return
				}
				first := updates[0]
				// –°–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –º–µ–¥–∏–∞–≥—Ä—É–ø–ø—ã
				var texts []string
				for _, u := range updates {
					if u.Message.Caption != "" {
						texts = append(texts, u.Message.Caption)
					} else if u.Message.Text != "" {
						texts = append(texts, u.Message.Text)
					}
				}
				caption := strings.Join(texts, "\n")
				attachments := []*entity.Upload{}
				for _, u := range updates {
					a, _ := t.processAttachments(u)
					attachments = append(attachments, a...)
				}
				newComment := &entity.Comment{
					TeamID:            tgChannel.TeamID,
					Platform:          "tg",
					UserPlatformID:    int(first.Message.From.ID),
					CommentPlatformID: first.Message.ID,
					FullName:          fmt.Sprintf("%s %s", first.Message.From.FirstName, first.Message.From.LastName),
					Username:          first.Message.From.Username,
					Text:              caption,
					CreatedAt:         time.Unix(int64(first.Message.Date), 0),
					Attachments:       attachments,
				}
				t.setCommentRelations(newComment, post, replyToComment)
				err := t.setUserAvatar(newComment, first.Message.From.ID)
				if err != nil {
					log.Errorf("Failed to set user avatar: %v", err)
				}
				if newComment.Text == "" && len(newComment.Attachments) == 0 {
					return
				}
				commentID, err := t.commentRepo.AddComment(newComment)
				if err != nil {
					log.Errorf("Failed to save comment: %v", err)
					return
				}
				t.publishCommentEvent(ctx, tgChannel.TeamID, commentID, newComment.PostUnionID, entity.CommentCreated, newComment.CreatedAt)
			})
		}
		t.mediaGroupMutex.Unlock()
		return nil
	}
	// --- –ö–æ–Ω–µ—Ü –º–µ–¥–∏–∞–≥—Ä—É–ø–ø—ã ---

	newComment := &entity.Comment{
		TeamID:            tgChannel.TeamID,
		Platform:          "tg",
		UserPlatformID:    int(update.Message.From.ID),
		CommentPlatformID: update.Message.ID,
		FullName:          fmt.Sprintf("%s %s", update.Message.From.FirstName, update.Message.From.LastName),
		Username:          update.Message.From.Username,
		Text:              update.Message.Text,
		CreatedAt:         time.Unix(int64(update.Message.Date), 0),
	}

	// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–≤—è–∑–∏ —Å –ø–æ—Å—Ç–æ–º –∏–ª–∏ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–º
	t.setCommentRelations(newComment, post, replyToComment)

	// –ó–∞–≥—Ä—É–∂–∞–µ–º –∞–≤–∞—Ç–∞—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
	err = t.setUserAvatar(newComment, update.Message.From.ID)
	if err != nil {
		log.Errorf("Failed to set user avatar: %v", err)
		// –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–ª–æ–∂–µ–Ω–∏—è
	err = t.setCommentAttachments(newComment, update)
	if err != nil {
		log.Errorf("Failed to process attachments: %v", err)
		newComment.Text += "\n\n[‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–∏–∫—Ä–µ–ø–∏–ª –∫ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—é —Ñ–∞–π–ª—ã, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏—Ö –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å]"
		newComment.Text = strings.TrimSpace(newComment.Text)
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –ø—É—Å—Ç–æ–π
	if newComment.Text == "" && len(newComment.Attachments) == 0 {
		return nil
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
	commentID, err := t.commentRepo.AddComment(newComment)
	if err != nil {
		log.Errorf("Failed to save comment: %v", err)
		return err
	}

	// –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
	return t.publishCommentEvent(ctx, tgChannel.TeamID, commentID, newComment.PostUnionID, entity.CommentCreated, newComment.CreatedAt)
}

func (t *EventListener) handleCommentEdit(ctx context.Context, update *models.Update) error {
	log.Debugf("Received edited message: %s", update.EditedMessage.Text)

	// –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
	existingComment, err := t.commentRepo.GetCommentByPlatformID(update.EditedMessage.ID, "tg")
	if errors.Is(err, repo.ErrCommentNotFound) {
		return nil
	}
	if err != nil {
		log.Errorf("Failed to get comment: %v", err)
		return err
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
	existingComment.Text = update.EditedMessage.Text

	// –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–≤—è–∑–µ–π
	update.Message = update.EditedMessage // –£–Ω–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–µ—Ç–æ–¥–æ–≤
	_, _, replyToComment, err := t.getCommentContext(update)
	if err == nil && replyToComment != nil {
		existingComment.ReplyToCommentID = replyToComment.ID
		existingComment.PostUnionID = replyToComment.PostUnionID
	}

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–ª–æ–∂–µ–Ω–∏—è
	err = t.setCommentAttachments(existingComment, update)
	if err != nil {
		log.Errorf("Failed to process attachments: %v", err)
		existingComment.Text += "\n\n[‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–∏–∫—Ä–µ–ø–∏–ª –∫ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—é —Ñ–∞–π–ª—ã, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏—Ö –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å]"
		existingComment.Text = strings.TrimSpace(existingComment.Text)
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –ø—É—Å—Ç–æ–π
	if existingComment.Text == "" && len(existingComment.Attachments) == 0 {
		return nil
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
	err = t.commentRepo.EditComment(existingComment)
	if err != nil {
		log.Errorf("Failed to update comment: %v", err)
		return err
	}

	// –ü–æ–ª—É—á–∞–µ–º team ID
	tgChannel, err := t.teamRepo.GetTGChannelByDiscussionId(int(update.EditedMessage.Chat.ID))
	if err != nil {
		log.Errorf("Failed to get team ID: %v", err)
		return err
	}

	// –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
	return t.publishCommentEvent(ctx, tgChannel.TeamID, existingComment.ID, existingComment.PostUnionID, entity.CommentEdited, existingComment.CreatedAt)
}

func (t *EventListener) getCommentContext(update *models.Update) (*entity.TGChannel, *entity.PostPlatform, *entity.Comment, error) {
	discussionID := int(update.Message.Chat.ID)

	tgChannel, err := t.teamRepo.GetTGChannelByDiscussionId(discussionID)
	if errors.Is(err, repo.ErrTGChannelNotFound) {
		return nil, nil, nil, nil
	}
	if err != nil {
		log.Errorf("Failed to get team ID by discussion ID: %v", err)
		return nil, nil, nil, err
	}

	var post *entity.PostPlatform
	var replyToComment *entity.Comment

	if update.Message.ReplyToMessage != nil {
		post, replyToComment, err = t.resolveReplyTarget(update.Message.ReplyToMessage, tgChannel)
		if err != nil {
			return tgChannel, nil, nil, err
		}
	}

	return tgChannel, post, replyToComment, nil
}

func (t *EventListener) resolveReplyTarget(replyMsg *models.Message, tgChannel *entity.TGChannel) (*entity.PostPlatform, *entity.Comment, error) {
	// –°–ª—É—á–∞–π 1: –û—Ç–≤–µ—Ç –Ω–∞ –ø–µ—Ä–µ—Å–ª–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –∫–∞–Ω–∞–ª–∞
	if replyMsg.ForwardOrigin != nil && replyMsg.ForwardOrigin.MessageOriginChannel != nil {
		post, err := t.postRepo.GetPostPlatformByPost(
			replyMsg.ForwardOrigin.MessageOriginChannel.MessageID,
			tgChannel.ID,
			"tg",
		)
		if errors.Is(err, repo.ErrPostPlatformNotFound) {
			// –í–æ–∑–º–æ–∂–Ω–æ —ç—Ç–æ –æ—Ç–≤–µ—Ç –Ω–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
			replyToComment, err := t.commentRepo.GetCommentByPlatformID(replyMsg.ID, "tg")
			if errors.Is(err, repo.ErrCommentNotFound) {
				log.Debugf("Reply target not found as post or comment, ignoring")
				return nil, nil, nil
			}
			return nil, replyToComment, err
		}
		return post, nil, err
	}

	// –°–ª—É—á–∞–π 2: –û—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –æ–±—Å—É–∂–¥–µ–Ω–∏–∏
	log.Debugf("Received direct reply to comment: %s", replyMsg.Text)
	replyToComment, err := t.commentRepo.GetCommentByPlatformID(replyMsg.ID, "tg")
	if errors.Is(err, repo.ErrCommentNotFound) {
		log.Debugf("Reply target not found as comment, treating as regular comment")
		return nil, nil, nil
	}
	return nil, replyToComment, err
}

func (t *EventListener) setCommentRelations(comment *entity.Comment, post *entity.PostPlatform, replyToComment *entity.Comment) {
	if replyToComment != nil {
		comment.ReplyToCommentID = replyToComment.ID
		comment.PostUnionID = replyToComment.PostUnionID
		comment.PostPlatformID = replyToComment.PostPlatformID
	} else if post != nil {
		comment.PostUnionID = &post.PostUnionId
		comment.PostPlatformID = &post.PostId
	}
}

func (t *EventListener) setUserAvatar(comment *entity.Comment, userID int64) error {
	photos, err := t.bot.GetUserProfilePhotos(t.ctx, &bot.GetUserProfilePhotosParams{
		UserID: userID,
		Limit:  1,
	})
	if err != nil {
		return fmt.Errorf("failed to get user profile photos: %w", err)
	}

	if len(photos.Photos) == 0 {
		return nil // –ù–µ—Ç —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è
	}

	uploadFileId, err := t.saveFile(photos.Photos[0][0].FileID, "photo")
	if err != nil {
		return fmt.Errorf("failed to save user profile photo: %w", err)
	}

	upload, err := t.uploadUseCase.GetUpload(uploadFileId)
	if err != nil {
		return fmt.Errorf("failed to get uploaded avatar file: %w", err)
	}

	comment.AvatarMediaFile = upload
	return nil
}

func (t *EventListener) setCommentAttachments(comment *entity.Comment, update *models.Update) error {
	attachments, err := t.processAttachments(update)
	if err != nil {
		return err
	}
	comment.Attachments = attachments
	return nil
}

func (t *EventListener) publishCommentEvent(ctx context.Context, teamID, commentID int, postUnionID *int, eventType entity.CommentEventType, occurredAt time.Time) error {
	postID := 0
	if postUnionID != nil {
		postID = *postUnionID
	}

	event := &entity.CommentEvent{
		EventID:    fmt.Sprintf("tg-%d-%d", teamID, commentID),
		TeamID:     teamID,
		PostID:     postID,
		Type:       eventType,
		CommentID:  commentID,
		OccurredAt: occurredAt,
	}

	err := t.eventRepo.PublishCommentEvent(ctx, event)
	if err != nil {
		log.Errorf("Failed to publish comment event: %v", err)
	}
	return err
}
